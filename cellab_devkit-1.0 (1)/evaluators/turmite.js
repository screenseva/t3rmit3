    /*  Turmites
    
        Bit Usage:
            7,6 Turmite bits.
            4,3,2 direction.
            1,0 tile type.
        (Later I will use bit 5 for speed: 0 is normal speed, 1 is double.)
        
        As all non-turmite cells will have zero velocity, the state 4 
        will never arise.  I use this state as a "don't update" flag state.
        
        Cell is the cell I update, Source is its state, Target
        is a cell near Cell, Sink is Target's state, Mite & Tile
        are  new cell values I compute.
        
        (1) If Source is 4, don't change newbuffer Cell. Exit.
        
        (2) Else test Source against Turmite bits.  If these
            bits are zero, copy Source to Cell in new Buffer and
            exit.
            
        (3) Else Source has nonzero Turmite bits.  Use direction
            bits to select Target and load Sink.
            
        (4) If Sink is a Turmite in oldbuff or in newbuff,
            reverse direction of Source and put it in Cell.
            
        (5) Else use Source high, Cell low, as offset into
            lookup table to determine Mite state.
           
        (6) Put Mite in Target position in New Buffer.
        
        (7) Put 4 in Target position in Old Buffer to signal no
            update.
        
        (8) Mask Source to get Tile and put Tile in Cell in Old
            and New Buffers.
        
        Note that this evaluator manipulates the new map while
        it is being generated by accesses through the ncells
        argument.
    */
    
    /*  Order of neighbour indices chosen so XORing
        the index with 8 reverses the direction.  */
    rule.evaluator.nindex = [ -(map[0].phyx + 1), -map[0].phyx, -(map[0].phyx - 1),
                                                         1,
                               (map[0].phyx + 1),  map[0].phyx,  (map[0].phyx - 1),
                                                        -1 ];
    
    function turmite(cells, phyx, phyy, p, lut, ncells) {
        var self = cells[p];
        
        if (self != 4) {                // Cells with state 4 do not update new map
            var rself = self;
            if ((self & 0xC0) != 0) {   // Turmite bits set in cell ?
                rself ^= 0x10;          // Reverse direction
                // Index of neighbour in current direction
                var ni = p + rule.evaluator.nindex[((self >> 2) & 7)];
                var neigh = cells[ni];
                if ((neigh & 0xC0) == 0) {  // Is there a turmite there ?
                    //  Neighbour cell is vacant; we can go there
                    var mite = lut[(neigh << 8) | self];    // Look up mite
                    //  Is there a turmite in the new map at the cell's location ?
                    if ((ncells[ni] & 0xC0) == 0) {
                        ncells[ni] = mite;   // Put mite at target in new map
                        cells[ni] = 4;      // Set don't update as neighbour
                        self &= 3;          // Return tile bits
                        cells[p] = self;    // Change self to tile in old map
                    }
                }
            }
        } else {
            //  Don't update cell in new map
             self = ncells[p];
        }
        return self;
    }
