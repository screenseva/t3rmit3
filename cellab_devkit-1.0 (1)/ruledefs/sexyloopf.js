    /*
                        SexyloopF
                        
        This rule implements the F variant of Sexyloop, an
        extension of the work described in.
            Nicholas Oros and Chrystopher L. Nehaniv,
            "Sexyloop: Self-Reproduction, Evolution and
            Sex in Cellular Automata", Proceedings of the
            2007 IEEE Symposium on Artificial Life, 2007,
            pp. 130-138.
        http://uhra.herts.ac.uk/bitstream/handle/2299/6711/901918.pdf
        
        F-sexyloop is described in the paper:
            Nicholas Oros and Chrystopher L. Nehaniv, "Dude,
            where is my Sex Gene? --  Persistence of Sex over
            Evolutionary Time in Cellular Automata",
            Proceedings of the 2009 IEEE Symposium on Artificial
            Life, 2009.
        http://www.socsci.uci.edu/~noros/mypapers/OROS_2009_IEEE_ALIFE_b.pdf
        
        Sexyloop is an extension of Hiroki Sayama's Evoloops
        which adds the ability of replicators to exchange
        genetic information.  F-sexyloop builds upon the
        mechanism for genetic transfer of the M1 and M2 variants
        of Sexyloop by adding a "sex gene", which must be
        present in order for the sending organism to transfer
        its genome to the receiver. This gene is represented by
        a cell in state 9, and can be transferred to the
        receiver along with other genetic material.  The sex
        gene thus behaves like the F factor plasmid in bacteria
        which facilitates the transfer of genetic material
        during conjugation.  If a connection is made by an
        organism which lacks the F gene, the connection will
        persist until one or both organisms die, but no genetic
        transfer will occur.
        
        The rule uses 12 states (0-B) and the von Neumann
        neighborhood.  The "sexyloop" default starting pattern
        is the Evoloop 13-2 self-replicating loop with the
        addition of an F (state 9) to its genome.

        We use the vonn4 evaluator, which provides us the
        states of our von Neumann neighbours in oldstate as:

               CCCC   NNNN WWWW   EEEE SSSS

        Note that the lookup table index is 20 bits.  This rule
        and the vonn4 evaluator use the "auxiliary lookup table"
        mechanism to accommodate the one megabyte lookup table it
        requires.  This rule definition creates the lookup table
        in its prologue code and stores it in rule.program.lookaux,
        a Uint8Array.  The vonn4 evaluator then looks up new states
        in that array rather than the standard 64K lut array.

    */

    rule.worldtype = 13;         // 2D torus world
    rule.patreq = "sexyloopf";
    rule.palreq = "sexyloop";
    rule.ocodereq = "vonn4";

    /*  The tranrule array encodes the transition rules
        as 24 bit hexadecimal numbers in which the nybbles
        have the following meaning:

            C N E S W C'

        Each entry represents four actual entries in the lookup
        table, generated by rotational symmetry within the von
        Neumann neighbourhood.  Thus, an entry of:

            C N E S W C'

        is shorthand for the four entries:

            C N E S W C'
            C E S W N C'
            C S W N E C'
            C W N E S C'

        where C is the old state of the centre cell and C' is its
        new value.  The unpacking and mirror transform expansion
        into the lutaux array is handled by the code below
        the table.  */

    rule.program.tranrule = [
        0x000012, 0x000043, 0x000122, 0x000152, 0x000212, 0x000242,
        0x000422, 0x000452, 0x000752, 0x001022, 0x002141, 0x002171,
        0x002322, 0x011221, 0x012121, 0x012321, 0x012421, 0x012451,
        0x012526, 0x012626, 0x012721, 0x012751, 0x013421, 0x013721,
        0x014221, 0x014251, 0x014321, 0x014351, 0x014421, 0x014621,
        0x017221, 0x017251, 0x017561, 0x017621, 0x017721, 0x100011,
        0x100121, 0x100211, 0x100244, 0x100277, 0x101211, 0x101244,
        0x101277, 0x102021, 0x102111, 0x102121, 0x102131, 0x102211,
        0x102244, 0x102277, 0x102324, 0x102414, 0x102424, 0x102434,
        0x102511, 0x102527, 0x102543, 0x102577, 0x102717, 0x102727,
        0x102735, 0x105121, 0x105424, 0x105727, 0x106211, 0x106244,
        0x106277, 0x111121, 0x111221, 0x111244, 0x111251, 0x111277,
        0x111621, 0x112121, 0x112131, 0x112151, 0x112221, 0x112244,
        0x112277, 0x112321, 0x112424, 0x112434, 0x112527, 0x112543,
        0x112577, 0x112626, 0x112727, 0x112735, 0x113221, 0x113321,
        0x115424, 0x115727, 0x116244, 0x116277, 0x122244, 0x122277,
        0x122434, 0x122737, 0x123244, 0x123277, 0x124266, 0x124333,
        0x126276, 0x200012, 0x200022, 0x200042, 0x200052, 0x200060,
        0x200071, 0x200122, 0x200152, 0x200212, 0x200222, 0x200232,
        0x200242, 0x200260, 0x200272, 0x200324, 0x200423, 0x200452,
        0x200545, 0x200575, 0x200620, 0x200722, 0x200752, 0x201022,
        0x201122, 0x201222, 0x201422, 0x201722, 0x202022, 0x202032,
        0x202052, 0x202065, 0x202073, 0x202122, 0x202152, 0x202212,
        0x202222, 0x202232, 0x202323, 0x202422, 0x202452, 0x202525,
        0x202620, 0x202650, 0x202722, 0x202752, 0x203122, 0x203222,
        0x203422, 0x203452, 0x203722, 0x204122, 0x204222, 0x204422,
        0x205122, 0x205425, 0x205725, 0x206125, 0x206212, 0x206425,
        0x206725, 0x207122, 0x207222, 0x207722, 0x211222, 0x212222,
        0x212232, 0x212242, 0x212272, 0x212323, 0x213222, 0x214222,
        0x216222, 0x217222, 0x222242, 0x222272, 0x222342, 0x222372,
        0x222432, 0x222442, 0x222732, 0x222772, 0x223243, 0x223273,
        0x300013, 0x300022, 0x300032, 0x300043, 0x300074, 0x300123,
        0x300322, 0x300421, 0x301021, 0x301250, 0x302123, 0x302423,
        0x302521, 0x302723, 0x303321, 0x312123, 0x312423, 0x312521,
        0x312723, 0x324243, 0x324251, 0x324273, 0x325271, 0x327273,
        0x400001, 0x400021, 0x401020, 0x401120, 0x401220, 0x401250,
        0x401620, 0x402120, 0x402150, 0x402221, 0x402321, 0x402626,
        0x403120, 0x403221, 0x500025, 0x500125, 0x500215, 0x500232,
        0x500245, 0x500275, 0x500425, 0x500725, 0x502022, 0x502052,
        0x502125, 0x502152, 0x502425, 0x502725, 0x503120, 0x602020,
        0x602120, 0x602220, 0x602420, 0x602720, 0x612220, 0x622240,
        0x622270, 0x701020, 0x701120, 0x701220, 0x701250, 0x701620,
        0x702120, 0x702150, 0x702221, 0x702320, 0x702626, 0x703120,
        0x000191, 0x002191, 0x012431, 0x012499, 0x0124A1, 0x012731,
        0x012799, 0x0127A1, 0x012921, 0x012931, 0x012951, 0x012999,
        0x0129A1, 0x0129AA, 0x013921, 0x015626, 0x016226, 0x019221,
        0x019251, 0x019621, 0x019921, 0x01A241, 0x01A271, 0x01A291,
        0x01A421, 0x01A721, 0x01A921, 0x0212A1, 0x100121, 0x100299,
        0x101021, 0x101121, 0x101299, 0x101A2A, 0x102044, 0x102077,
        0x102099, 0x1021A1, 0x102299, 0x1024A4, 0x1025A7, 0x1027A7,
        0x102929, 0x102939, 0x1029A9, 0x102A21, 0x102AA0, 0x103121,
        0x103424, 0x103727, 0x103929, 0x103A21, 0x104121, 0x104A24,
        0x105626, 0x107121, 0x107A27, 0x109129, 0x109429, 0x109729,
        0x109929, 0x109A29, 0x10A121, 0x10A424, 0x10A727, 0x10A92A,
        0x10AA26, 0x111299, 0x111A21, 0x112131, 0x112199, 0x1121A1,
        0x112299, 0x112599, 0x1125A7, 0x112929, 0x112931, 0x1129AA,
        0x112AA1, 0x113424, 0x113727, 0x113921, 0x113A21, 0x114A24,
        0x115626, 0x115929, 0x116226, 0x116299, 0x117A27, 0x119429,
        0x119729, 0x119929, 0x119A29, 0x11A424, 0x11A727, 0x11A92A,
        0x11AA26, 0x1212A1, 0x122299, 0x122466, 0x122766, 0x122966,
        0x123299, 0x1242A4, 0x124566, 0x124AA6, 0x126296, 0x1272A7,
        0x127566, 0x127AA6, 0x1292A9, 0x129566, 0x129A4A, 0x129A7A,
        0x129A9A, 0x129AA6, 0x12AA44, 0x12AA77, 0x12AA99, 0x200092,
        0x200232, 0x200292, 0x200595, 0x200650, 0x200922, 0x200952,
        0x201922, 0x202092, 0x2020A2, 0x202192, 0x2021A2, 0x202242,
        0x202272, 0x202292, 0x202312, 0x202342, 0x202372, 0x202392,
        0x202492, 0x2024A2, 0x202792, 0x2027A2, 0x202912, 0x202922,
        0x202952, 0x202992, 0x2029A2, 0x202A22, 0x20322A, 0x2034A2,
        0x205925, 0x206925, 0x209122, 0x209222, 0x209922, 0x20A122,
        0x20A422, 0x20A722, 0x20A922, 0x212262, 0x212292, 0x212622,
        0x21322A, 0x219222, 0x222292, 0x2222A2, 0x222392, 0x22243A,
        0x22273A, 0x22293A, 0x222972, 0x222992, 0x223293, 0x300003,
        0x300093, 0x3020A3, 0x302123, 0x3021A3, 0x3024A3, 0x3027A3,
        0x3029A9, 0x30A123, 0x30A423, 0x30A521, 0x30A723, 0x30A923,
        0x312123, 0x3121A3, 0x312423, 0x3124A3, 0x312723, 0x3127A3,
        0x312923, 0x3129A9, 0x31A423, 0x31A521, 0x31A521, 0x31A723,
        0x31A923, 0x324A43, 0x324A73, 0x324A93, 0x327A43, 0x327A73,
        0x327A93, 0x329A49, 0x329A79, 0x329A99, 0x34A524, 0x37A527,
        0x39A529, 0x402130, 0x4021A0, 0x4029AA, 0x402A20, 0x405626,
        0x406226, 0x40A120, 0x40A210, 0x500295, 0x500620, 0x502925,
        0x602052, 0x602152, 0x602200, 0x602210, 0x602240, 0x602270,
        0x602290, 0x602452, 0x602752, 0x602920, 0x602952, 0x605220,
        0x60AA22, 0x615220, 0x61AA22, 0x622450, 0x622750, 0x622950,
        0x624AA2, 0x627AA2, 0x629AA2, 0x702130, 0x702199, 0x7021A0,
        0x7029AA, 0x702A20, 0x705626, 0x706226, 0x70A120, 0x70A210,
        0x900210, 0x901020, 0x901120, 0x901210, 0x901220, 0x901250,
        0x901270, 0x901620, 0x902120, 0x902130, 0x902150, 0x9021AA,
        0x902221, 0x902320, 0x902626, 0x9029AA, 0x902A20, 0x903120,
        0x905626, 0x906226, 0x90A020, 0x90A120, 0x90A210, 0x90A420,
        0x90A720, 0x90A920, 0xA0022A, 0xA020AA, 0xA02121, 0xA021AA,
        0xA0221A, 0xA0224A, 0xA0227A, 0xA0229A, 0xA022AA, 0xA024AA,
        0xA027AA, 0xA029AA, 0xA02AA1, 0xA0322A, 0xA0922A, 0xA0A12A,
        0xA0A42A, 0xA0A72A, 0xA0A92A, 0xA11A2A, 0xA12121, 0xA12161,
        0xA121AA, 0xA12272, 0xA122AA, 0xA124AA, 0xA12727, 0xA127AA,
        0xA12929, 0xA129AA, 0xA12A24, 0xA12AA1, 0xA1322A, 0xA16222,
        0xA16A21, 0xA1922A, 0xA1A42A, 0xA1A72A, 0xA1A92A, 0xA2243A,
        0xA2249A, 0xA2273A, 0xA2279A, 0xA2293A, 0xA2299A, 0xA22A3A,
        0xA22A4A, 0xA22A62, 0xA22A7A, 0xA22A9A, 0xA24A4A, 0xA24A7A,
        0xA24A9A, 0xA27A4A, 0xA27A7A, 0xA27A9A, 0xA29A4A, 0xA29A7A,
        0xA29A9A, 0xA2AA41, 0xA2AA71, 0xA2AA91, 0x500925, 0x000242,
        0x000272, 0x000292, 0x700120, 0x400120, 0x900120, 0x09242B,
        0x09272B, 0x192029, 0x192129, 0x49212B, 0x79212B, 0xB2020B,
        0xB2021B, 0xB2024B, 0xB2027B, 0x0B2421, 0x0B2721, 0x1B2021,
        0x1B2121, 0x4B2120, 0x7B2120, 0x0B1A21, 0x1B7A27, 0x1B4A24,
        0x1B1A2A, 0xB1212B, 0xB12429, 0xB12729, 0x4B0A20, 0x7B0A20,
        0x1B1A2A, 0x2B2212, 0x2B2242, 0x2B2272, 0x2B2202, 0x2B2022,
        0x2A0502, 0x2A0512, 0x2A0542, 0x2A0572, 0xAAA222, 0xAAA211,
        0xAAA206, 0x2A1225, 0x692122, 0x161211, 0x621212, 0x561225,
        0x651212, 0x522215, 0x262152, 0x591200, 0x9A5201, 0x122011,
        0x191029, 0x276222, 0x7A0201, 0xA77222, 0x056771, 0x262202,
        0x972000, 0x102599
    ];

    //  Construct lookup table, expanding and applying symmetry

    rule.program.lutaux = new Uint8Array(new ArrayBuffer(1 << 20));
    rule.program.lutaux.fill(0xFF);     // Fill to detect undefined slots

    /*  Compute lookup table index for the states of the
        centre cell and its four von Neumann neighbours.
        Example                      N   E   S   W    */
    rule.program.osidx = function(c, n1, n2, n3, n4) {
        return (c  << 16) |
               (n1 << 12) |
               (n2 <<  4) |
               (n4 <<  8) |
                n3;
    };

    for (var i = 0; i < rule.program.tranrule.length; i++) {
        /*  Transform cell states from table entry into
            vonn4 packed table index.  */
        var t = rule.program.tranrule[i];
        var tC  = (t >> 20),
            tN  = (t >> 16) & 0xF,
            tE  = (t >> 12) & 0xF,
            tS  = (t >>  8) & 0xF,
            tW  = (t >>  4) & 0xF,
            tCp =  t        & 0xF;

        /*  Now create four lookup table entries, all
            yielding the same tCp new state, with the
            four rotations of the specified neighbour
            cell states.  (Note that in some cases the
            rotations will be degenerate and set the same
            lookup table entry; no harm done.)  */

        rule.program.lutaux[rule.program.osidx(tC, tN, tE, tS, tW)] =
        rule.program.lutaux[rule.program.osidx(tC, tE, tS, tW, tN)] =
        rule.program.lutaux[rule.program.osidx(tC, tS, tW, tN, tE)] =
        rule.program.lutaux[rule.program.osidx(tC, tW, tN, tE, tS)] = tCp;
    }

    var a, b, c, d, e;

    /*  Define rules concerning state 8

        After all of the normal transition rules for the
        self-reproducing loop automaton have been defined
        below, using states 0-B, the following code fills in
        undefined entries in the lookup table with state 8.
        Undefined states occur when two structures collide,
        and mapping them to state 8 triggers the process of
        "structural dissolution" or death, as the state 8
        propagates back along the structures which collided.  */

    for (a = 0; a <= 11; a++) {
        for (b = 0; b <= 11; b++) {
            for (c = 0; c <= 11; c++) {
                for (d = 0; d <= 11; d++) {
                    for (e = 0; e <= 11; e++) {
                        if (rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] ==
                            0xFF) {
                            if (a == 8) {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                            } else if ((b == 8) || (c == 8) || (d == 8) || (e == 8)) {
                                switch (a) {
                                    case 0:
                                    case 1:
                                        if (((b >= 2) && (b <= 7)) || ((c >= 2) && (c <= 7)) ||
                                            ((d >= 2) && (d <= 7)) || ((e >= 2) && (e <= 7))) {
                                            rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 8;
                                        } else {
                                            rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = a;
                                        }
                                        break;

                                    case 2:
                                    case 3:
                                    case 5:
                                        rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                                        break;

                                    case 4:
                                    case 6:
                                    case 7:
                                        rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 1;
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /*  Lookup table entries which remain undefined after the
        previous process are set to 0 if the centre cell's state
        is 0 and 8 (the dissolution state) otherwise.  */

    for (a = 0; a <= 11; a++) {
        for (b = 0; b <= 11; b++) {
            for (c = 0; c <= 11; c++) {
                for (d = 0; d <= 11; d++) {
                    for (e = 0; e <= 11; e++) {
                        if (rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] == 0xFF) {
                            if (a == 0) {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                            } else {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 8;
                            }
                        }
                    }
                }
            }
        }
    }

    function sexyloopf(oldstate) {
        return 0;       // 64K lookup table isn't used
    }
