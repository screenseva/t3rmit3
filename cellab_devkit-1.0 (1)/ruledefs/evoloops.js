    /*
                        Evoloops

        This is an implementation of Evoloops: a
        self-reproducing extension of Langton's loops with
        death and evolution.  Evoloops were developed by
        Hiroki Sayama and are described in his Web site:

        http://necsi.edu/postdocs/sayama/sdsr/index.html

        and in detail in his Ph.D. thesis:

        http://necsi.edu/postdocs/sayama/sdsr/download/PhD-sayama.pdf

        We use the vonn4 evaluator, which provides us the
        states of our von Neumann neighbours in oldstate as:

               CCCC   NNNN WWWW   EEEE SSSS

        Note that the lookup table index is 20 bits.  This rule
        and the vonn4 evaluator use the "auxiliary lookup table"
        mechanism to accommodate the one megabyte lookup table it
        requires.  This rule definition creates the lookup table
        in its prologue code and stores it in rule.program.lookaux,
        a Uint8Array.  The vonn4 evaluator then looks up new states
        in that array rather than the standard 64K lut array.

    */

    rule.worldtype = 13;         // 2D torus world
    rule.patreq = "evoloops";
    rule.palreq = "evoloops";
    rule.ocodereq = "vonn4";

    /*  The tranrule array encodes the transition rules
        as 24 bit hexadecimal numbers in which the nybbles
        have the following meaning:

            C N E S W C'

        Each entry represents four actual entries in the lookup
        table, generated by rotational symmetry within the von
        Neumann neighbourhood.  Thus, an entry of:

            C N E S W C'

        is shorthand for the four entries:

            C N E S W C'
            C E S W N C'
            C S W N E C'
            C W N E S C'

        where C is the old state of the centre cell and C' is its
        new value.  The unpacking and mirror transform expansion
        into the lutaux array is handled by the code below
        the table.  */

    rule.program.tranrule = [
        0x000012, 0x000043, 0x000122, 0x000152, 0x000212,
        0x000242, 0x000422, 0x000452, 0x000752, 0x001022,
        0x002141, 0x002171, 0x002322, 0x011221, 0x012121,
        0x012321, 0x012421, 0x012451, 0x012526, 0x012626,
        0x012721, 0x012751, 0x013421, 0x013721, 0x014221,
        0x014251, 0x014321, 0x014351, 0x014421, 0x014621,
        0x017221, 0x017251, 0x017561, 0x017621, 0x017721,
        0x100011, 0x100121, 0x100211, 0x100244, 0x100277,
        0x101211, 0x101244, 0x101277, 0x102021, 0x102111,
        0x102121, 0x102131, 0x102211, 0x102244, 0x102277,
        0x102324, 0x102414, 0x102424, 0x102434, 0x102511,
        0x102527, 0x102543, 0x102577, 0x102717, 0x102727,
        0x102735, 0x105121, 0x105424, 0x105727, 0x106211,
        0x106244, 0x106277, 0x111121, 0x111221, 0x111244,
        0x111251, 0x111277, 0x111621, 0x112121, 0x112131,
        0x112151, 0x112221, 0x112244, 0x112277, 0x112321,
        0x112424, 0x112434, 0x112527, 0x112543, 0x112577,
        0x112626, 0x112727, 0x112735, 0x113221, 0x113321,
        0x115424, 0x115727, 0x116244, 0x116277, 0x122244,
        0x122277, 0x122434, 0x122737, 0x123244, 0x123277,
        0x124266, 0x124333, 0x126276, 0x200012, 0x200022,
        0x200042, 0x200052, 0x200060, 0x200071, 0x200122,
        0x200152, 0x200212, 0x200222, 0x200232, 0x200242,
        0x200260, 0x200272, 0x200324, 0x200423, 0x200452,
        0x200545, 0x200575, 0x200620, 0x200722, 0x200752,
        0x201022, 0x201122, 0x201222, 0x201422, 0x201722,
        0x202022, 0x202032, 0x202052, 0x202065, 0x202073,
        0x202122, 0x202152, 0x202212, 0x202222, 0x202232,
        0x202323, 0x202422, 0x202452, 0x202525, 0x202620,
        0x202650, 0x202722, 0x202752, 0x203122, 0x203222,
        0x203422, 0x203452, 0x203722, 0x204122, 0x204222,
        0x204422, 0x205122, 0x205425, 0x205725, 0x206125,
        0x206212, 0x206425, 0x206725, 0x207122, 0x207222,
        0x207722, 0x211222, 0x212222, 0x212232, 0x212242,
        0x212272, 0x212323, 0x213222, 0x214222, 0x216222,
        0x217222, 0x222242, 0x222272, 0x222342, 0x222372,
        0x222432, 0x222442, 0x222732, 0x222772, 0x223243,
        0x223273, 0x300013, 0x300022, 0x300032, 0x300043,
        0x300074, 0x300123, 0x300322, 0x300421, 0x301021,
        0x301250, 0x302123, 0x302423, 0x302521, 0x302723,
        0x303321, 0x312123, 0x312423, 0x312521, 0x312723,
        0x324243, 0x324251, 0x324273, 0x325271, 0x327273,
        0x400001, 0x400021, 0x401020, 0x401120, 0x401220,
        0x401250, 0x401620, 0x402120, 0x402150, 0x402221,
        0x402321, 0x402626, 0x403120, 0x403221, 0x500025,
        0x500125, 0x500215, 0x500232, 0x500245, 0x500275,
        0x500425, 0x500725, 0x502022, 0x502052, 0x502125,
        0x502152, 0x502425, 0x502725, 0x503120, 0x602022,
        0x602122, 0x602220, 0x602422, 0x602722, 0x612220,
        0x622240, 0x622270, 0x701020, 0x701120, 0x701220,
        0x701250, 0x701620, 0x702120, 0x702150, 0x702221,
        0x702320, 0x702626, 0x703120
    ];

    //  Construct lookup table, expanding and applying symmetry

    rule.program.lutaux = new Uint8Array(new ArrayBuffer(1 << 20));
    rule.program.lutaux.fill(0xFF);     // Fill to detect undefined slots

    /*  Compute lookup table index for the states of the
        centre cell and its four von Neumann neighbours.
        Example                      N   E   S   W    */
    rule.program.osidx = function(c, n1, n2, n3, n4) {
        return (c  << 16) |
               (n1 << 12) |
               (n2 <<  4) |
               (n4 <<  8) |
                n3;
    };

    for (var i = 0; i < rule.program.tranrule.length; i++) {
        /*  Transform cell states from table entry into
            vonn4 packed table index.  */
        var t = rule.program.tranrule[i];
        var tC  = (t >> 20),
            tN  = (t >> 16) & 0xF,
            tE  = (t >> 12) & 0xF,
            tS  = (t >>  8) & 0xF,
            tW  = (t >>  4) & 0xF,
            tCp =  t        & 0xF;

        /*  Now create four lookup table entries, all
            yielding the same tCp new state, with the
            four rotations of the specified neighbour
            cell states.  (Note that in some cases the
            rotations will be degenerate and set the same
            lookup table entry; no harm done.)  */

        rule.program.lutaux[rule.program.osidx(tC, tN, tE, tS, tW)] =
        rule.program.lutaux[rule.program.osidx(tC, tE, tS, tW, tN)] =
        rule.program.lutaux[rule.program.osidx(tC, tS, tW, tN, tE)] =
        rule.program.lutaux[rule.program.osidx(tC, tW, tN, tE, tS)] = tCp;
    }

    var a, b, c, d, e;

    /*  Define rules concerning state 8

        After all of the normal transition rules for the
        self-reproducing loop automaton have been defined
        below, using states 0-7, the following code fills in
        undefined entries in the lookup table with state 8.
        Undefined states occur when two structures collide,
        and mapping them to state 8 triggers the process of
        "structural dissolution" or death, as the state 8
        propagates back along the structures which collided.  */

    for (a = 0; a <= 8; a++) {
        for (b = 0; b <= 8; b++) {
            for (c = 0; c <= 8; c++) {
                for (d = 0; d <= 8; d++) {
                    for (e = 0; e <= 8; e++) {
                        if (rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] ==
                            0xFF) {
                            if (a == 8) {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                            } else if ((b == 8) || (c == 8) || (d == 8) || (e == 8)) {
                                switch (a) {
                                    case 0:
                                    case 1:
                                        if (((b >= 2) && (b <= 7)) || ((c >= 2) && (c <= 7)) ||
                                            ((d >= 2) && (d <= 7)) || ((e >= 2) && (e <= 7))) {
                                            rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 8;
                                        } else {
                                            rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = a;
                                        }
                                        break;

                                    case 2:
                                    case 3:
                                    case 5:
                                        rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                                        break;

                                    case 4:
                                    case 6:
                                    case 7:
                                        rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 1;
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /*  Lookup table entries which remain undefined after the
        previous process are set to 0 if the centre cell's state
        is 0 and 8 (the dissolution state) otherwise.  */

    for (a = 0; a <= 8; a++) {
        for (b = 0; b <= 8; b++) {
            for (c = 0; c <= 8; c++) {
                for (d = 0; d <= 8; d++) {
                    for (e = 0; e <= 8; e++) {
                        if (rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] == 0xFF) {
                            if (a == 0) {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                            } else {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 8;
                            }
                        }
                    }
                }
            }
        }
    }

    function evoloops(oldstate) {
        return 0;       // 64K lookup table isn't used
    }
