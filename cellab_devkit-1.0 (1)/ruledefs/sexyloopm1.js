    /*
                        SexyloopM1
                        
        This rule implements the M1 variant of Sexyloop, as
        described by:
            Nicholas Oros and Chrystopher L. Nehaniv,
            "Sexyloop: Self-Reproduction, Evolution and
            Sex in Cellular Automata", Proceedings of the
            2007 IEEE Symposium on Artificial Life, 2007,
            pp. 130-138.
        http://uhra.herts.ac.uk/bitstream/handle/2299/6711/901918.pdf
        
        Sexyloop is an extension of Hiroki Sayama's Evoloops
        which adds the ability of replicators to exchange
        genetic information.  The M1 variant is the simplest
        form of Sexyloop.  When a replicator makes contact with
        another, it waits until the start of the signal loop in
        the destination replicator before transferring its genes
        to it.  See the paper cited above for complete details. 
        Initial patterns are compatible with Evoloops.  The rule
        uses 10 states (0-9) and the von Neumann neighborhood.

        We use the vonn4 evaluator, which provides us the
        states of our von Neumann neighbours in oldstate as:

               CCCC   NNNN WWWW   EEEE SSSS

        Note that the lookup table index is 20 bits.  This rule
        and the vonn4 evaluator use the "auxiliary lookup table"
        mechanism to accommodate the one megabyte lookup table it
        requires.  This rule definition creates the lookup table
        in its prologue code and stores it in rule.program.lookaux,
        a Uint8Array.  The vonn4 evaluator then looks up new states
        in that array rather than the standard 64K lut array.

    */

    rule.worldtype = 13;         // 2D torus world
    rule.patreq = "sexyloopm";
    rule.palreq = "sexyloop";
    rule.ocodereq = "vonn4";

    /*  The tranrule array encodes the transition rules
        as 24 bit hexadecimal numbers in which the nybbles
        have the following meaning:

            C N E S W C'

        Each entry represents four actual entries in the lookup
        table, generated by rotational symmetry within the von
        Neumann neighbourhood.  Thus, an entry of:

            C N E S W C'

        is shorthand for the four entries:

            C N E S W C'
            C E S W N C'
            C S W N E C'
            C W N E S C'

        where C is the old state of the centre cell and C' is its
        new value.  The unpacking and mirror transform expansion
        into the lutaux array is handled by the code below
        the table.  */

    rule.program.tranrule = [
        0x000012, 0x000043, 0x000122, 0x000152, 0x000212, 0x000242,
        0x000422, 0x000452, 0x000752, 0x001022, 0x002141, 0x002171,
        0x002322, 0x011221, 0x012121, 0x012321, 0x012421, 0x012451,
        0x012526, 0x012626, 0x012721, 0x012751, 0x013421, 0x013721,
        0x014221, 0x014251, 0x014321, 0x014351, 0x014421, 0x014621,
        0x017221, 0x017251, 0x017561, 0x017621, 0x017721, 0x100011,
        0x100121, 0x100211, 0x100244, 0x100277, 0x101211, 0x101244,
        0x101277, 0x102021, 0x102111, 0x102121, 0x102131, 0x102211,
        0x102244, 0x102277, 0x102324, 0x102414, 0x102424, 0x102434,
        0x102511, 0x102527, 0x102543, 0x102577, 0x102717, 0x102727,
        0x102735, 0x105121, 0x105424, 0x105727, 0x106211, 0x106244,
        0x106277, 0x111121, 0x111221, 0x111244, 0x111251, 0x111277,
        0x111621, 0x112121, 0x112151, 0x112221, 0x112244, 0x112277,
        0x112321, 0x112424, 0x112434, 0x112527, 0x112543, 0x112577,
        0x112626, 0x112727, 0x112735, 0x113221, 0x113321, 0x115424,
        0x115727, 0x116244, 0x116277, 0x122244, 0x122277, 0x122434,
        0x122737, 0x123244, 0x123277, 0x124266, 0x124333, 0x126276,
        0x200012, 0x200022, 0x200042, 0x200052, 0x200060, 0x200071,
        0x200122, 0x200152, 0x200212, 0x200222, 0x200232, 0x200242,
        0x200260, 0x200272, 0x200324, 0x200423, 0x200452, 0x200545,
        0x200575, 0x200620, 0x200722, 0x200752, 0x201022, 0x201122,
        0x201222, 0x201422, 0x201722, 0x202022, 0x202032, 0x202052,
        0x202065, 0x202073, 0x202122, 0x202152, 0x202212, 0x202222,
        0x202232, 0x202323, 0x202422, 0x202452, 0x202525, 0x202620,
        0x202650, 0x202722, 0x202752, 0x203122, 0x203222, 0x203422,
        0x203452, 0x203722, 0x204122, 0x204222, 0x204422, 0x205122,
        0x205425, 0x205725, 0x206125, 0x206212, 0x206425, 0x206725,
        0x207122, 0x207222, 0x207722, 0x211222, 0x212222, 0x212232,
        0x212242, 0x212272, 0x212323, 0x213222, 0x214222, 0x216222,
        0x217222, 0x222242, 0x222272, 0x222342, 0x222372, 0x222432,
        0x222442, 0x222732, 0x222772, 0x223243, 0x223273, 0x300013,
        0x300022, 0x300032, 0x300043, 0x300074, 0x300123, 0x300322,
        0x300421, 0x301021, 0x301250, 0x302123, 0x302423, 0x302521,
        0x302723, 0x303321, 0x312123, 0x312423, 0x312521, 0x312723,
        0x324243, 0x324251, 0x324273, 0x325271, 0x327273, 0x400001,
        0x400021, 0x401020, 0x401120, 0x401220, 0x401250, 0x401620,
        0x402120, 0x402150, 0x402221, 0x402321, 0x402626, 0x403120,
        0x403221, 0x500025, 0x500125, 0x500215, 0x500232, 0x500245,
        0x500275, 0x500425, 0x500725, 0x502022, 0x502052, 0x502125,
        0x502152, 0x502425, 0x502725, 0x503120, 0x602022, 0x602122,
        0x602220, 0x602422, 0x602722, 0x612220, 0x622240, 0x622270,
        0x701020, 0x701120, 0x701220, 0x701250, 0x701620, 0x702120,
        0x702150, 0x702221, 0x702320, 0x702626, 0x703120, 0x011321,
        0x011421, 0x011921, 0x012141, 0x012151, 0x012171, 0x012431,
        0x012731, 0x012929, 0x015626, 0x016226, 0x016326, 0x019221,
        0x019241, 0x019271, 0x019421, 0x019721, 0x101929, 0x102191,
        0x102494, 0x102797, 0x102921, 0x103121, 0x103424, 0x103727,
        0x104924, 0x105626, 0x106226, 0x107927, 0x111921, 0x112131,
        0x112196, 0x112494, 0x112797, 0x112921, 0x113429, 0x113729,
        0x114924, 0x115626, 0x116226, 0x116929, 0x117927, 0x119221,
        0x122466, 0x122491, 0x122766, 0x122791, 0x124291, 0x124566,
        0x127291, 0x127566, 0x200192, 0x200650, 0x201322, 0x202043,
        0x202092, 0x202192, 0x202242, 0x202272, 0x202299, 0x202922,
        0x203192, 0x204322, 0x205192, 0x207322, 0x209122, 0x209422,
        0x209722, 0x212262, 0x212299, 0x212622, 0x222292, 0x222949,
        0x222979, 0x226292, 0x300060, 0x302023, 0x302921, 0x312921,
        0x324294, 0x327297, 0x402130, 0x402921, 0x405626, 0x406226,
        0x409120, 0x409210, 0x409221, 0x416226, 0x500060, 0x500620,
        0x500650, 0x600220, 0x602050, 0x602150, 0x602210, 0x602240,
        0x602270, 0x602320, 0x602450, 0x602750, 0x603210, 0x609122,
        0x612192, 0x612250, 0x612320, 0x612492, 0x612792, 0x619922,
        0x623240, 0x623270, 0x702130, 0x702921, 0x705626, 0x706226,
        0x709120, 0x709210, 0x709221, 0x716226, 0x902029, 0x902129,
        0x902131, 0x902299, 0x902429, 0x902729, 0x909129, 0x912129,
        0x912199, 0x912299, 0x912429, 0x912499, 0x912729, 0x912799,
        0x912921, 0x912991, 0x916921, 0x922949, 0x922962, 0x922979,
        0x924249, 0x924279, 0x927279
    ];

    //  Construct lookup table, expanding and applying symmetry

    rule.program.lutaux = new Uint8Array(new ArrayBuffer(1 << 20));
    rule.program.lutaux.fill(0xFF);     // Fill to detect undefined slots

    /*  Compute lookup table index for the states of the
        centre cell and its four von Neumann neighbours.
        Example                      N   E   S   W    */
    rule.program.osidx = function(c, n1, n2, n3, n4) {
        return (c  << 16) |
               (n1 << 12) |
               (n2 <<  4) |
               (n4 <<  8) |
                n3;
    };

    for (var i = 0; i < rule.program.tranrule.length; i++) {
        /*  Transform cell states from table entry into
            vonn4 packed table index.  */
        var t = rule.program.tranrule[i];
        var tC  = (t >> 20),
            tN  = (t >> 16) & 0xF,
            tE  = (t >> 12) & 0xF,
            tS  = (t >>  8) & 0xF,
            tW  = (t >>  4) & 0xF,
            tCp =  t        & 0xF;

        /*  Now create four lookup table entries, all
            yielding the same tCp new state, with the
            four rotations of the specified neighbour
            cell states.  (Note that in some cases the
            rotations will be degenerate and set the same
            lookup table entry; no harm done.)  */

        rule.program.lutaux[rule.program.osidx(tC, tN, tE, tS, tW)] =
        rule.program.lutaux[rule.program.osidx(tC, tE, tS, tW, tN)] =
        rule.program.lutaux[rule.program.osidx(tC, tS, tW, tN, tE)] =
        rule.program.lutaux[rule.program.osidx(tC, tW, tN, tE, tS)] = tCp;
    }

    var a, b, c, d, e;

    /*  Define rules concerning state 8

        After all of the normal transition rules for the
        self-reproducing loop automaton have been defined
        above, using states 0-9, the following code fills in
        undefined entries in the lookup table with state 8.
        Undefined states occur when two structures collide,
        and mapping them to state 8 triggers the process of
        "structural dissolution" or death, as the state 8
        propagates back along the structures which collided.  */

    for (a = 0; a <= 9; a++) {
        for (b = 0; b <= 9; b++) {
            for (c = 0; c <= 9; c++) {
                for (d = 0; d <= 9; d++) {
                    for (e = 0; e <= 9; e++) {
                        if (rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] ==
                            0xFF) {
                            if (a == 8) {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                            } else if ((b == 8) || (c == 8) || (d == 8) || (e == 8)) {
                                switch (a) {
                                    case 0:
                                    case 1:
                                        if (((b >= 2) && (b <= 7)) || ((c >= 2) && (c <= 7)) ||
                                            ((d >= 2) && (d <= 7)) || ((e >= 2) && (e <= 7))) {
                                            rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 8;
                                        } else {
                                            rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = a;
                                        }
                                        break;

                                    case 2:
                                    case 3:
                                    case 5:
                                        rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                                        break;

                                    case 4:
                                    case 6:
                                    case 7:
                                        rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 1;
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /*  Lookup table entries which remain undefined after the
        previous process are set to 0 if the centre cell's state
        is 0 and 8 (the dissolution state) otherwise.  */

    for (a = 0; a <= 9; a++) {
        for (b = 0; b <= 9; b++) {
            for (c = 0; c <= 9; c++) {
                for (d = 0; d <= 9; d++) {
                    for (e = 0; e <= 9; e++) {
                        if (rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] == 0xFF) {
                            if (a == 0) {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 0;
                            } else {
                                rule.program.lutaux[rule.program.osidx(a, b, c, d, e)] = 8;
                            }
                        }
                    }
                }
            }
        }
    }

    function sexyloopm1(oldstate) {
        return 0;       // 64K lookup table isn't used
    }
